package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/fatih/structtag"
	"golang.org/x/tools/imports"
)

func main() {
	log.SetPrefix("accessor: ")

	var fileName string
	var receiver string
	var getter, setter, scanner, private bool

	flag.StringVar(&fileName, "f", "", "file name")
	flag.StringVar(&receiver, "receiver", "", "receiver name")
	flag.BoolVar(&getter, "getter", true, "generate getter")
	flag.BoolVar(&setter, "setter", true, "generate setter")
	flag.BoolVar(&scanner, "scanner", true, "generate scanner")
	flag.BoolVar(&private, "private", true, "with private")
	flag.Parse()

	// fileName = "/Users/smzgl/代码区/智慧医药/NGOS-IC/ic-server/internal/domain/support/openapi/qcloud/trade/internal/domain/model/order.go"
	// fileName = "/Users/smzgl/代码区/智慧医药/NGOS-IC/go-accessor/a.go"
	// fileName = "/Users/smzgl/代码区/智慧医药/NGOS-IC/ic-server/internal/domain/support/openapi/qcloud/trade/internal/interfaces/proto/goods_detail.go"

	if fileName == "" {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	gen := generator{
		fileName:     fileName,
		withGetter:   getter,
		withSetter:   setter,
		withScanner:  scanner,
		withPrivate:  private,
		withReceiver: receiver,
	}

	gen.parsePackageFiles([]string{fileName})

	dir := filepath.Dir(fileName)
	name := filepath.Base(fileName)
	if ext := filepath.Ext(name); ext != "" {
		name = name[:len(name)-len(ext)]
	}

	output := filepath.Join(dir, strings.ToLower(fmt.Sprintf("%s_accessor.go", name)))

	data, err := imports.Process(output, gen.generate(), nil)
	if err != nil {
		log.Fatalf("go import failed: %s", err)
	}

	if err := os.WriteFile(output, data, 0644); err != nil {
		log.Fatalf("write file(%s) failed: %s", output, err)
	}
}

type generator struct {
	fileName     string
	withGetter   bool
	withSetter   bool
	withScanner  bool
	withPrivate  bool
	withReceiver string
	buf          bytes.Buffer
	pkg          *pkg
}

func (g *generator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

type file struct {
	pkg  *pkg
	file *ast.File
}

type pkg struct {
	dir   string
	name  string
	files []*file
}

func (g *generator) parsePackageDir(dir string) {
	pkg, err := build.Default.ImportDir(dir, 0)
	if err != nil {
		log.Fatalf("import dir(%s) failed:%s", dir, err)
	}

	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)

	g.parsePackage(dir, makePath(dir, names))
}

func (g *generator) parsePackageFiles(names []string) {
	g.parsePackage(".", names)
}

func makePath(dir string, names []string) []string {
	if dir == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(dir, name)
	}
	return ret
}

func (g *generator) parsePackage(dir string, names []string) {
	var files []*file
	var astFiles []*ast.File
	g.pkg = new(pkg)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("parse package %s failed: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &file{
			file: parsedFile,
			pkg:  g.pkg,
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("no buildable go files:%s", dir)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = dir
}

func (g *generator) generate() []byte {
	for _, file := range g.pkg.files {
		if file.file == nil {
			continue
		}

		ast.Inspect(file.file, func(node ast.Node) bool {
			decl, ok := node.(*ast.GenDecl)
			if !ok || decl.Tok != token.TYPE {
				return true
			}

			for _, spec := range decl.Specs {
				tspec := spec.(*ast.TypeSpec)
				stype, ok := tspec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if g.buf.Len() == 0 {
					g.Printf("// Code generated by \"go-accessor\"; DO NOT EDIT.\n\n")
					g.Printf("package %s\n", g.pkg.name)
					g.Printf("\n")
					g.Printf("import \"%s\"\n", "github.com/jinzhu/copier")
					g.Printf("import \"%s\"\n", "github.com/modern-go/reflect2")
				}

				g.build(tspec.Name.Name, stype)
			}

			return true
		})
	}

	if g.buf.Len() == 0 {
		return nil
	}

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("format source faild:%s, \n%s", err, string(g.buf.Bytes()))
	}
	g.buf.Reset()
	return src
}

// const (
// 	getterFormat = `// %[2]s return %[3]s value
// func (t %[1]s) Get%[2]s() %[4]s {
// 	return t.%[3]s
// }
// `
// 	setterFormat = `// Set%[2]s set v to %[3]s
// func (t *%[1]s) Set%[2]s(v %[4]s) {
// 	t.%[3]s = v
// }
// `
// )

func (g *generator) build(typeName string, typ *ast.StructType) {
	if typ.Fields.NumFields() == 0 {
		// log.Println("struct has no field")
		return
	}

	for _, field := range typ.Fields.List {

		var tag *structtag.Tag

		if field.Tag != nil {
			tagValue := strings.TrimSpace(field.Tag.Value)
			tagValue = strings.Trim(tagValue, "`")

			tags, err := structtag.Parse(tagValue)
			if err != nil {
				log.Printf("err: %v", err)
			}

			if tags != nil {
				tag, _ = tags.Get("accessor")
			}
		}
		// TODO: check field tag
		for _, name := range field.Names {
			if name.Name[0] == '_' {
				continue
			}

			if !name.IsExported() && !g.withPrivate {
				continue
			}

			typ := toTypeString(field.Type)
			if typ == "" {
				continue
			}

			exportName := strings.ToUpper(string(name.Name[0])) + name.Name[1:]

			rawType := ""

			if tag != nil {
				for _, tagOpt := range tag.Options {
					if !strings.HasPrefix(tagOpt, "type:") {
						continue
					}

					_, rawType, _ = strings.Cut(tagOpt, ":")
					if rawType == "" {
						rawType = ""
					}
				}
			}

			rawType = strings.TrimSpace(rawType)
			if rawType == "" {
				rawType = typ
			}

			if g.withGetter {
				g.genGetter(typeName, name.Name, exportName, typ, rawType)
			}

			if g.withSetter {
				g.genSetter(typeName, name.Name, exportName, typ, rawType)
			}

			if g.withScanner {
				g.genScanner(typeName, name.Name, exportName, typ, rawType)
			}
		}

	}
}

func (g *generator) isPrimitive(typeName string) bool {
	primitiveTypes := []string{
		"int", "uint", "string", "time.Time",
	}

	primitivePkgs := []string{"enum", "status"}

	for _, s := range primitiveTypes {
		if strings.HasPrefix(typeName, s) {
			return true
		}
	}

	for _, s := range primitivePkgs {
		if strings.HasPrefix(typeName, s+".") || strings.Contains(typeName, "."+s+".") {
			return true
		}
	}

	return false
}

func (g *generator) executeTemplate(templateName, templateString,
	structName, fieldName, exportName, typeName, rawTypeName string) {

	t := template.New(templateName).Funcs(template.FuncMap{
		"HasPrefix": func(s string, prefixes ...string) bool {
			for _, prefix := range prefixes {
				if strings.HasPrefix(s, prefix) {
					return true
				}
			}
			return false
		},
	})

	t = template.Must(t.Parse(templateString))

	receiverName := g.withReceiver
	if receiverName == "" {
		receiverName = strings.ToLower(structName[0:1])
	}

	var typePointer string
	if typeName[0] == '*' {
		typeName = typeName[1:]
		typePointer = "*"
	}

	var rawPointer string
	if rawTypeName[0] == '*' {
		rawTypeName = rawTypeName[1:]
		rawPointer = "*"
	}

	typeName = strings.TrimLeft(typeName, "*")
	rawTypeName = strings.TrimLeft(rawTypeName, "*")

	if g.isPrimitive(rawTypeName) {
		rawTypeName = "primitive"
	}

	err := t.Execute(&g.buf, map[string]string{
		"Receiver":   receiverName,
		"Struct":     structName,
		"Field":      fieldName,
		"Name":       exportName,
		"Pointer":    typePointer,
		"Type":       typeName,
		"RawPointer": rawPointer,
		"RawType":    rawTypeName,
	})

	if err != nil {
		log.Fatalf("template execute fail, err: %+v", err)
	}
}

func (g *generator) genGetter(structName, fieldName, exportName, typeName, rawTypeName string) {
	// int      -> int
	// uint     -> uint
	// string   -> string
	// []       -> []
	// map      -> map
	//
	// Message  -> *Message
	//
	// *int      -> int
	// *uint     -> uint
	// *string   -> string
	// *[]       -> []
	// *map      -> map
	//
	// *Message  -> *Message

	tpl := `
	{{if or (eq .RawType "primitive") (HasPrefix .RawType "[]" "map") -}}
	func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() (value {{.Type}}) {
		if {{.Receiver}} == nil {{if .RawPointer -}} || {{.Receiver}}.{{.Field}} == nil {{end -}} {
			return
		}
	
		return {{.RawPointer}}{{.Receiver}}.{{.Field}}
	}
	{{else -}}
	func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() (value *{{.Type}}) {
		if {{.Receiver}} == nil {
			return
		}
	
		return {{if not .RawPointer -}} & {{- end -}}{{.Receiver}}.{{.Field}}
	}
	{{end -}}
	`

	// 	tpl := `
	// func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() (value {{.Type}}) {
	// 	if {{.Receiver}} == nil {{if .RawPointer -}} || {{.Receiver}}.{{.Field}} == nil {{end -}} {
	// 		return
	// 	}
	//
	// 	return {{.RawPointer}}{{.Receiver}}.{{.Field}}
	// }
	// `

	g.executeTemplate("getter", tpl, structName, fieldName, exportName, typeName, rawTypeName)
}

func (g *generator) genSetter(structName, fieldName, exportName, typeName, rawTypeName string) {

	// int      -> int
	// uint     -> uint
	// string   -> string
	// []       -> []
	// map      -> map
	//
	// Message  -> *Message
	//
	// *int      -> int
	// *uint     -> uint
	// *string   -> string
	// *[]       -> []
	// *map      -> map
	//
	// *Message  -> *Message

	tpl := `
{{if or (eq .RawType "primitive") (HasPrefix .RawType "[]" "map") -}}
func ({{.Receiver}} *{{.Struct}}) Set{{.Name}}(value {{.Type}})  {
	{{.Receiver}}.{{.Field}} = {{if .RawPointer -}} & {{- end -}} value
}
{{else -}}
func ({{.Receiver}} *{{.Struct}}) Set{{.Name}}(value *{{.Type}}) {
	{{.Receiver}}.{{.Field}} = {{if not .RawPointer -}} * {{- end -}} value
}
{{end -}}
`

	g.executeTemplate("setter", tpl, structName, fieldName, exportName, typeName, rawTypeName)
}

func (g *generator) genScanner(structName, fieldName, exportName, typeName, rawTypeName string) {

	// int      -> int
	// uint     -> uint
	// string   -> string
	// []       -> []
	// map      -> map
	//
	// Message  -> *Message
	//
	// *int      -> int
	// *uint     -> uint
	// *string   -> string
	// *[]       -> []
	// *map      -> map
	//
	// *Message  -> *Message

	tpl := `
{{if eq .RawType "primitive" -}}
func ({{.Receiver}} *{{.Struct}}) Scan{{.Name}}(value interface{}) (err error) {
	if reflect2.IsNil(value) {
		return nil
	}

	// if _, ok := value.(interface{ MarshalValuer() }); !ok {
	// 	if valuer, ok := value.(driver.Valuer); ok {
	// 		value, err = valuer.Value()
	// 		if err != nil {
	// 			return err
	// 		}
	// 	}
	// }

	{{if .RawPointer -}} 
	{{.Receiver}}.{{.Field}} = new({{.Type}})
	{{end -}}

	return copier.Copy(&{{.Receiver}}.{{.Field}}, value)	
}
{{else -}}
func ({{.Receiver}} *{{.Struct}}) Scan{{.Name}}(value interface{}) (err error) {
	if reflect2.IsNil(value) {
		return nil
	}

	// if _, ok := value.(interface{ MarshalValuer() }); !ok {
	// 	if valuer, ok := value.(driver.Valuer); ok {
	// 		value, err = valuer.Value()
	// 		if err != nil {
	// 			return err
	// 		}
	// 	}
	// }

	{{.Receiver}}.{{.Field}} = {{if .RawPointer -}} & {{- end -}} {{.Type}}{}
	return copier.Copy(&{{.Receiver}}.{{.Field}}, value)	
}
{{end -}}
`
	g.executeTemplate("scanner", tpl, structName, fieldName, exportName, typeName, rawTypeName)
}

// TODO: fix bad function
func toTypeString(exp ast.Expr) string {
	switch x := exp.(type) {
	case *ast.Ident:
		if x.Obj != nil {
			typs := x.Obj.Decl.(*ast.TypeSpec)
			if !typs.Name.IsExported() {
				return ""
			}
		}
	case *ast.StarExpr:
		if toTypeString(x.X) == "" {
			return ""
		}
	case *ast.ArrayType:
		if toTypeString(x.Elt) == "" {
			return ""
		}
	case *ast.MapType:
		if toTypeString(x.Key) == "" || toTypeString(x.Value) == "" {
			return ""
		}
	case *ast.FuncType:
		for _, f := range x.Params.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
		for _, f := range x.Results.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
	case *ast.StructType: // TODO: anonymous struct
		return ""
	case *ast.SelectorExpr:
	default:
		return ""
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, token.NewFileSet(), exp); err != nil {
		log.Fatalf("format ast.Expr failed:%s", err)
	}

	return buf.String()
}
