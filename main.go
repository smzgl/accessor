package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

func main() {
	log.SetPrefix("accessor: ")

	var fileName string
	var receiver string
	var getter, setter, private bool

	flag.StringVar(&fileName, "f", "", "file name")
	flag.BoolVar(&getter, "getter", false, "generate getter")
	flag.BoolVar(&setter, "setter", false, "generate setter")
	flag.BoolVar(&setter, "private", false, "generate setter")
	flag.StringVar(&receiver, "receiver", "", "generate setter")
	flag.Parse()

	if fileName == "" {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	gen := generator{
		fileName:     fileName,
		withGetter:   getter,
		withSetter:   setter,
		withPrivate:  private,
		withReceiver: receiver,
	}

	gen.parsePackageFiles([]string{fileName})

	dir := filepath.Dir(fileName)
	name := filepath.Base(fileName)
	if ext := filepath.Ext(name); ext != "" {
		name = name[:len(name)-len(ext)]
	}

	output := filepath.Join(dir, strings.ToLower(fmt.Sprintf("%s_accessor.go", name)))

	data, err := imports.Process(output, gen.generate(), nil)
	if err != nil {
		log.Fatalf("go import failed: %s", err)
	}

	if err := os.WriteFile(output, data, 0644); err != nil {
		log.Fatalf("write file(%s) failed: %s", output, err)
	}
}

type generator struct {
	fileName     string
	withGetter   bool
	withSetter   bool
	withPrivate  bool
	withReceiver string
	buf          bytes.Buffer
	pkg          *pkg
}

func (g *generator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

type file struct {
	pkg  *pkg
	file *ast.File
}

type pkg struct {
	dir   string
	name  string
	files []*file
}

func (g *generator) parsePackageDir(dir string) {
	pkg, err := build.Default.ImportDir(dir, 0)
	if err != nil {
		log.Fatalf("import dir(%s) failed:%s", dir, err)
	}

	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)

	g.parsePackage(dir, makePath(dir, names))
}

func (g *generator) parsePackageFiles(names []string) {
	g.parsePackage(".", names)
}

func makePath(dir string, names []string) []string {
	if dir == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(dir, name)
	}
	return ret
}

func (g *generator) parsePackage(dir string, names []string) {
	var files []*file
	var astFiles []*ast.File
	g.pkg = new(pkg)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("parse package %s failed: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &file{
			file: parsedFile,
			pkg:  g.pkg,
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("no buildable go files:%s", dir)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = dir
}

func (g *generator) generate() []byte {
	for _, file := range g.pkg.files {
		if file.file == nil {
			continue
		}

		ast.Inspect(file.file, func(node ast.Node) bool {
			decl, ok := node.(*ast.GenDecl)
			if !ok || decl.Tok != token.TYPE {
				return true
			}
			for _, spec := range decl.Specs {
				tspec := spec.(*ast.TypeSpec)
				stype, ok := tspec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if g.buf.Len() == 0 {
					g.Printf("// Code generated by \"accessor %s\"; DO NOT EDIT.\n\n")
					g.Printf("package %s\n", g.pkg.name)
				}

				g.build(tspec.Name.Name, stype)
			}

			return true
		})
	}

	if g.buf.Len() == 0 {
		return nil
	}

	log.Println(g.buf.String())

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("format source faild:%s", err)
	}
	g.buf.Reset()
	return src
}

// const (
// 	getterFormat = `// %[2]s return %[3]s value
// func (t %[1]s) Get%[2]s() %[4]s {
// 	return t.%[3]s
// }
// `
// 	setterFormat = `// Set%[2]s set v to %[3]s
// func (t *%[1]s) Set%[2]s(v %[4]s) {
// 	t.%[3]s = v
// }
// `
// )

func (g *generator) build(typeName string, typ *ast.StructType) {
	if typ.Fields.NumFields() == 0 {
		log.Println("struct has no field")
		return
	}

	for _, field := range typ.Fields.List {
		// TODO: check field tag
		for _, name := range field.Names {

			if name.Name[0] == '_' {
				continue
			}

			if !name.IsExported() && !g.withPrivate {
				continue
			}

			typ := toTypeString(field.Type)
			if typ == "" {
				continue
			}

			exportName := strings.ToUpper(string(name.Name[0])) + name.Name[1:]

			if g.withGetter {
				// g.Printf(getterFormat, typeName, exportName, name.Name, typ)
				g.genGetter(typeName, name.Name, exportName, typ)
			}

			if g.withSetter {
				// g.Printf(setterFormat, typeName, exportName, name.Name, typ)
				g.genSetter(typeName, name.Name, exportName, typ)
			}
		}
	}
}

func (g *generator) genGetter(structName, fieldName, exportName, typeName string) {
	tpl := `
func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() {{.Type}} {
	return {{.Receiver}}.{{.Field}}
}
`

	tplPtr := `
{{ if or (HasPrefix .Type "int") (HasPrefix .Type "uint") -}}
func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() {{.Type}} {
	if {{.Receiver}} != nil && {{.Receiver}}.{{.Field}} != nil {
		return *{{.Receiver}}.{{.Field}}
	}	
	return 0	
}
{{- else if HasPrefix .Type "string" -}}
func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() {{.Type}} {
	if {{.Receiver}} != nil && {{.Receiver}}.{{.Field}} != nil {
		return *{{.Receiver}}.{{.Field}}
	}	
	return ""	
}
{{- else -}}
func ({{.Receiver}} *{{.Struct}}) Get{{.Name}}() *{{.Type}} {
	if {{.Receiver}} != nil && {{.Receiver}}.{{.Field}} != nil {
		return *{{.Receiver}}.{{.Field}}
	}	
	return nil
}
{{- end}}
`

	t := template.New("getter").Funcs(template.FuncMap{
		"HasPrefix": strings.HasPrefix,
	})

	if typeName[0] == '*' {
		t = template.Must(t.Parse(tplPtr))
		typeName = typeName[1:]
	} else {
		t = template.Must(t.Parse(tpl))
	}

	receiverName := g.withReceiver
	if receiverName == "" {
		receiverName = strings.ToLower(structName[0:1])
	}

	err := t.Execute(&g.buf, map[string]string{
		"Receiver": receiverName,
		"Struct":   structName,
		"Field":    fieldName,
		"Type":     typeName,
		"Name":     exportName,
	})

	if err != nil {
		log.Fatalf("template execute fail, err: %+v", err)
	}
}

func (g *generator) genSetter(structName, fieldName, exportName, typeName string) {
	tpl := `
func ({{.Receiver}} *{{.Struct}}) Set{{.Name}}(param {{.Type}}) {
	{{.Receiver}}.{{.Field}} = param
}
`

	tplPtr := `
func ({{.Receiver}} *{{.Struct}}) Set{{.Name}}(param {{.Type}}) {
	*{{.Receiver}}.{{.Field}} = param
}
`

	t := template.New("setter")

	if typeName[0] == '*' {
		t = template.Must(t.Parse(tplPtr))
		typeName = typeName[1:]
	} else {
		t = template.Must(t.Parse(tpl))
	}

	err := t.Execute(&g.buf, map[string]string{
		"Receiver": strings.ToLower(structName[0:1]),
		"Struct":   structName,
		"Field":    fieldName,
		"Type":     typeName,
		"Name":     exportName,
	})

	if err != nil {
		log.Fatalf("template execute fail, err: %+v", err)
	}
}

// TODO: fix bad function
func toTypeString(exp ast.Expr) string {
	switch x := exp.(type) {
	case *ast.Ident:
		if x.Obj != nil {
			typs := x.Obj.Decl.(*ast.TypeSpec)
			if !typs.Name.IsExported() {
				return ""
			}
		}
	case *ast.StarExpr:
		if toTypeString(x.X) == "" {
			return ""
		}
	case *ast.ArrayType:
		if toTypeString(x.Elt) == "" {
			return ""
		}
	case *ast.MapType:
		if toTypeString(x.Key) == "" || toTypeString(x.Value) == "" {
			return ""
		}
	case *ast.FuncType:
		for _, f := range x.Params.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
		for _, f := range x.Results.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
	case *ast.StructType: // TODO: anonymous struct
		return ""
	case *ast.SelectorExpr:
	default:
		return ""
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, token.NewFileSet(), exp); err != nil {
		log.Fatalf("format ast.Expr failed:%s", err)
	}

	return buf.String()
}
